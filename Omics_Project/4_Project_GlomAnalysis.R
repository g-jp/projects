# Omics Approaches: projetc
# Paper: Crucial genes associated with diabetic nephropathy explored by microarray analysis

#____________________________RNA normalization analysis____________________________

BiocManager::install("GEOquery")
BiocManager::install("tidyverse")

library("affy")
library("GEOquery")
library("tidyverse")

# The analysis begins with the .CEL files generated by affymetrix RNA image analysis
# which contain the raw information extracted from the probes.They need to undergo normalization first.

getGEOSuppFiles('GSE1009') # get the .CEL files from GEO

untar("GSE1009/GSE1009_RAW.tar", exdir = 'data_RAW/') # extract the raw files

raw.data = ReadAffy(celfile.path='data_RAW/') # read the .cel files

# ReadAffy is an AffyBatch object that stores the data from the .cel files for further analysis

norm.data = rma(raw.data) # perform sample normalization

norm.expr = exprs(norm.data) # fetch the normalized data in a matrix form

df.normexp = as.data.frame(norm.expr) # transform the matrix into a df

gse = getGEO('GSE1009', GSEMatrix = TRUE) # map the probes ID to gene symbols

feature.data = gse$GSE1009_series_matrix.txt.gz@featureData@data # indexing of the gse object to fetch the genes ID for different classification (feature data -> data)

feature.data = feature.data[,c(1,11)] # recover the affymetrix ID and gene symbol

df.normexp = df.normexp %>% # Don't ask me about this symbol =)
  rownames_to_column(var = 'ID') %>% # Lines to merge the gene symbols with the original df.normexp using the affym IDs as intersection 
  inner_join(., feature.data, by = 'ID')

# %>% ## The pipe operator can make complex data manipulation or analysis code more readable by avoiding nested function calls (check ChatGPT).

samples = colnames(df.normexp)[c(1:length(colnames(df.normexp))-1)]

# write.table(df.normexp, file = "matrix_GSE1009", sep = "\t", row.names = FALSE)

heatmap(cor(df.normexp[samples]))

nullelements.out <- c()

new.genelist <- c()

gene.symbol <- df.normexp$`Gene Symbol` # extract all gene symbols matched in my previous gene list

# check for non-null gene symbols
for (gene in gene.symbol){
  if (gene == ''){
    next
  }
  else{
    nullelements.out <- c(nullelements.out,gene)
  }
}

# check for repeated gene symbols
for (gene in gene.symbol){
  if(gene == ''){
    next
  }
  else {
    if (!(gene %in% new.genelist)){ # the ! character negates what follows, and the %in% statement is a in-built R operator to check if what is on the left side is present on what is on the right side
      new.genelist <- c(new.genelist,gene) 
    }
  }
}

# compute how many repeated entries there are
repeated = length(nullelements.out) - length(new.genelist) # 2981

# R test__________________________________
for (i in df.normexp$GSM15965.CEL.gz){ # perform a loop in R using for, () and {}
  if (i > 10){
    print(df.normexp$`Gene Symbol`[i])
  }
}

add <- function(x, y){ # define a new function in R by storing the function statement in a new variable with the function name
  result = (x + y)^2
  return(result) # return statement for the desired result
}

add(10,2)
# R test__________________________________


#____________________________Differential gene expression analysis____________________________

library("limma")

design <- model.matrix(~0 + factor(c(rep("Control", 3), factor(c(rep("Replicate", 3)))))) # Create a design matrix

# Assign column names to the design matrix
colnames(design) <- c("Tests","Controls")
rownames(design) <- c("GSM15965.CEL.gz", "GSM15966.CEL.gz", "GSM15967.CEL.gz", "GSM15968.CEL.gz", "GSM15969.CEL.gz", "GSM15970.CEL.gz")

contrasts = makeContrasts(Tests - Controls, levels = design) # Define contrasts to compare each replicate with its respective control

fit <- lmFit(df.normexp, design) # fit the data in a linear model. This creates a MArrayLM object that is read further down

fit <- contrasts.fit(fit,contrasts = contrasts) # perform comparison based on predetermined groups

fit <- eBayes(fit) # evaluate statistics of each signal

exp.result <- topTable(fit, adjust.method = 'BH',number=Inf) %>% # show results with adjusted p_val 
  rownames_to_column(var = 'ID') %>%
  inner_join(., feature.data, by = 'ID') %>%
  column_to_rownames(var = 'ID')

vars <- colnames(exp.result)

library(ggplot2)

ggplot(exp.result, aes(x = logFC, y = -log10(adj.P.Val))) + #ggplot initializes the ggplot object and serves as a resevoir for the df obj and the vectors in it that will serve as variables
  geom_point(aes(color = ifelse(abs(logFC) > 1 & adj.P.Val < 0.05, "blue", "gray")), alpha = 0.7) +
  scale_color_identity() +
  labs(x = "Log Fold Change", y = "-log10(p-value)", title = "Volcano Plot") +
  theme_minimal() +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") +
  geom_vline(xintercept = 1, linetype = "solid", color = "gray") +
  geom_vline(xintercept = -1, linetype = "solid", color = "gray")

## write.table(exp.result, file = "Diff_analysis_GSE1009", sep = "\t", row.names = FALSE)

filtered.expres <- exp.result %>%
  subset(exp.result$`Gene Symbol` != '' & adj.P.Val < 0.05) %>%# filtered exp.results for differential, significant genes
  group_by(`Gene Symbol`) %>% # if a column name has two separate words, they must be handled using the `` encompassing them
  filter(logFC == median(logFC)) %>% 
  subset(abs(logFC) >= 1)
  #summarize(across(logFC, list(~ median(.))))# %>% 

'testdf <- data.frame() # loop to confirm grouping and condition selection
i = 0
for(gene in unique(exp.result[exp.result$`Gene Symbol`!= '',]$`Gene Symbol`)){
  i = i + 1
  table <- exp.result[exp.result$`Gene Symbol` == gene,]
  table <- summarize(table, across(everything(), list(logFC = ~ median(.))))
  print(i)
  print(gene)
  testdf <- rbind(testdf,table)
}
'
testdf2 <- subset(testdf,abs(logFC)>=1 & adj.P.Val < 0.05)

diff.genes <- filtered.expres$`Gene Symbol`

table <- data.frame() # loop for grouping df entries according to gene symbols


#____________________________Functional Enrichment____________________________

library(clusterProfiler)
library(org.Hs.eg.db)

# Retrieve the universe to be used in the over-representation step

universe <- exp.result[exp.result$`Gene Symbol`!= '', ]$`Gene Symbol` %>% unique() # Extract all genes identified by the affymetrix analysis

enric.bp <- enrichGO(diff.genes,
                     OrgDb=org.Hs.eg.db, 
                     keyType="ENTREZID",
                     ont="BP",
                     pvalueCutoff = 0.1,
                     pAdjustMethod = "BH", 
                     universe=universe, 
                     minGSSize = 20, 
                     maxGSSize=300, 
                     readable = T)
library(DOSE)

enric.bp@result$FoldEnrichment=parse_ratio(enric.bp@result$GeneRatio)/parse_ratio(enric.bp@result$BgRatio)

enric.bp.df <- as.data.frame(enric.bp)

dotplot(enric.bp, x="FoldEnrichment",color="p.adjust",size="Count",showCategory=20,orderBy="Count")

feature.data1 <- gse$GSE1009_series_matrix.txt.gz@featureData@data
feature.data1 <- feature.data1[,c(11,12)] 
df.difgenes <- as.data.frame(diff.genes)
colnames(df.difgenes) <- 'Gene Symbol'

universeEntrez <- as.data.frame(universe)
colnames(universeEntrez) <- 'Gene Symbol'

universeEntrez <- unique(inner_join(universeEntrez, feature.data1, by = 'Gene Symbol'))
universeEntrez <- universeEntrez$ENTREZ_GENE_ID

df.difgenes <- unique(inner_join(df.difgenes, feature.data1, by = 'Gene Symbol'))
df.difgenes <- df.difgenes$ENTREZ_GENE_ID

kk <- enrichKEGG(gene = df.difgenes,
                 organism = 'hsa',
                 pAdjustMethod = "BH",
                 universe = universeEntrez,
                 pvalueCutoff = 0.05,
                 minGSSize = 10,
                 maxGSSize = 500)

kk@result$FoldEnrichment=parse_ratio(kk@result$GeneRatio)/parse_ratio(kk@result$BgRatio)

kkdf=as.data.frame(kk)

browseKEGG(kk, 'hsa04919')

# Retrieve a non-repeated gene list for the over-representation step____________________________
diff.probes <- exp.result$`Gene Symbol`[abs(exp.result$logFC) > 1 & exp.result$adj.P.Val < 0.05]
diff.probes.unique <- diff.probes %>%
  unique()
diff.probes.unique <- diff.probes.unique[diff.probes.unique != '']

diff.probes.unique <- as.data.frame(diff.probes.unique)
#_______________________________________________________________________________________________

